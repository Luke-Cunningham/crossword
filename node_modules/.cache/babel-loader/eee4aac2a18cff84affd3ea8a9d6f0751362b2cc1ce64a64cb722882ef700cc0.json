{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/Users/lukecunningham/Documents/GitHub/crossword-app/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.convertIpuz = exports.isSupportedIpuz = exports.isIpuzData = exports.useIpuz = void 0;\nvar react_1 = require(\"react\");\nvar IpuzURI = 'http://ipuz.org';\nvar IpuzVersionURI = \"\".concat(IpuzURI, \"/v\");\nvar IpuzVersion = 2;\nvar IpuzCrosswordURI = \"\".concat(IpuzURI, \"/crossword#\");\nvar IpuzCrosswordVersion = 1;\nvar directionMap = {\n  Across: 'across',\n  Down: 'down'\n};\nfunction useIpuz(data) {\n  return (0, react_1.useMemo)(function () {\n    if (!isIpuzData(data)) {\n      // eslint-disable-next-line no-console\n      console.error('useIpuz() was not given IPUZ data');\n      return null;\n    }\n    if (!isSupportedIpuz(data)) {\n      // eslint-disable-next-line no-console\n      console.error('useIpuz() was not given supported IPUZ data');\n      return null;\n    }\n    return convertIpuz(data);\n  }, [data]);\n}\nexports.useIpuz = useIpuz;\n/** Inspects a value to see if it looks like IPUZ data. */\nfunction isIpuzData(data) {\n  return !!data && typeof data === 'object' && 'version' in data && typeof data.version === 'string' && data.version.startsWith(IpuzVersionURI);\n}\nexports.isIpuzData = isIpuzData;\n/** Checks to see whether the IPUZ data is supported. */\nfunction isSupportedIpuz(ipuz) {\n  var version = Number.parseInt(ipuz.version.substring(IpuzVersionURI.length), 10);\n  if (version > IpuzVersion) {\n    return false;\n  }\n  if (ipuz.kind.length !== 1 || !ipuz.kind[0].startsWith(IpuzCrosswordURI)) {\n    return false;\n  }\n  var crosswordVersion = Number.parseInt(ipuz.kind[0].substring(IpuzCrosswordURI.length), 10);\n  if (crosswordVersion > IpuzCrosswordVersion) {\n    return false;\n  }\n  return true;\n}\nexports.isSupportedIpuz = isSupportedIpuz;\n/** Converts an IPUZ crossword to our internal format. */\nfunction convertIpuz(ipuz) {\n  // loop through the puzzle and figure out the row/col of each clue...\n  var clueLocs = ipuz.puzzle.reduce(function (memoOuter, rowData, row) {\n    return rowData.reduce(function (memoInner, cell, col) {\n      var _a;\n      var key = typeof cell === 'object' ? (_a = cell === null || cell === void 0 ? void 0 : cell.cell) !== null && _a !== void 0 ? _a : -1 : cell;\n      memoInner[key.toString()] = {\n        row: row,\n        col: col\n      };\n      return memoInner;\n    }, memoOuter);\n  }, {});\n  // console.log('GOT CLUE LOCS', clueLocs);\n  var converted = Object.fromEntries(Object.entries(ipuz.clues).map(function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n      dir = _ref2[0],\n      clueList = _ref2[1];\n    var dirClues = clueList.reduce(function (memo, _ref3) {\n      var _ref4 = _slicedToArray(_ref3, 2),\n        num = _ref4[0],\n        clueText = _ref4[1];\n      // console.log('looking for', dir, num);\n      var _clueLocs$num$toStrin = clueLocs[num.toString()],\n        row = _clueLocs$num$toStrin.row,\n        col = _clueLocs$num$toStrin.col;\n      // get the answer by inspecting the solution grid\n      var answer = '';\n      var dr = dir === 'Across' ? 0 : 1;\n      var dc = dir === 'Across' ? 1 : 0;\n      for (var r = row, c = col; r < ipuz.dimensions.height && c < ipuz.dimensions.width; r += dr, c += dc) {\n        var ch = ipuz.solution[r][c];\n        if (!ch || ch === '#') {\n          break;\n        }\n        answer += ch;\n      }\n      memo[num.toString()] = {\n        clue: clueText,\n        answer: answer,\n        row: row,\n        col: col\n      };\n      return memo;\n    }, {});\n    return [directionMap[dir], dirClues];\n  }));\n  return converted;\n}\nexports.convertIpuz = convertIpuz;","map":{"version":3,"names":["react_1","require","IpuzURI","IpuzVersionURI","concat","IpuzVersion","IpuzCrosswordURI","IpuzCrosswordVersion","directionMap","Across","Down","useIpuz","data","useMemo","isIpuzData","console","error","isSupportedIpuz","convertIpuz","exports","version","startsWith","ipuz","Number","parseInt","substring","length","kind","crosswordVersion","clueLocs","puzzle","reduce","memoOuter","rowData","row","memoInner","cell","col","key","_a","toString","converted","Object","fromEntries","entries","clues","map","_ref","_ref2","_slicedToArray","dir","clueList","dirClues","memo","_ref3","_ref4","num","clueText","_clueLocs$num$toStrin","answer","dr","dc","r","c","dimensions","height","width","ch","solution","clue"],"sources":["/Users/lukecunningham/Documents/GitHub/crossword-app/node_modules/@jaredreisinger/react-crossword/src/ipuz.ts"],"sourcesContent":["import { useMemo } from 'react';\nimport { CluesInputOriginal, ClueTypeOriginal } from './types';\n\n/**\n * IPUZ-format JSON data input format.  See http://www.ipuz.org/ for details.\n * Note that only the fields/values supported by this crossword component are\n * used.\n */\nexport interface IpuzInput {\n  /** IPUZ version for this puzzle */\n  version: string;\n\n  /** Kind (IPUZ URI) of this puzzle (must have at least one kind) */\n  kind: string[];\n\n  // general/optional fields...\n\n  /** Copyright information */\n  copyright?: string;\n  /** Name and/or reference for a publisher */\n  publisher?: string;\n  /** Bibliographic reference for a published puzzle */\n  publication?: string;\n  /** Permanent URL for the puzzle */\n  url?: string;\n  /** Globally unique identifier for the puzzle */\n  uniqueid?: string;\n  /** Title of puzzle */\n  title?: string;\n  /** Text displayed above puzzle */\n  intro?: string;\n  /** Text displayed after successful solve */\n  explanation?: string;\n  /** Non-displayed annotation */\n  annotation?: string;\n  /** Author of puzzle */\n  author?: string;\n  /** Editor of puzzle */\n  editor?: string;\n  /** Date of puzzle or publication date */\n  date?: string;\n  /** Notes about the puzzle */\n  notes?: string;\n  /** Informational only, there is no standard for difficulty */\n  difficulty?: string;\n  /** Characters that can be entered in the puzzle */\n  charset?: string;\n  /** Program-specific information from program that wrote this file */\n  origin?: string;\n  /** Text value which represents a block (defaults to \"#\") */\n  block?: string;\n  /** Value which represents an empty cell (defaults to 0) */\n  empty?: string;\n  /** Named styles for the puzzle */\n  styles?: unknown;\n\n  // crossword information...\n\n  /** Dimensions of the puzzle grid */\n  dimensions: {\n    width: number;\n    height: number;\n  };\n\n  /** The puzzle rows, then columns (describes the rendered cells) */\n  puzzle: (number | string | null | { cell?: number; style?: unknown })[][];\n\n  /** Correct solution (row-major cell answers) */\n  solution: (string | null)[][];\n\n  /** The final answer to the puzzle */\n  answer?: unknown; // how is this different from solution?\n\n  /** Clue sets (each set is array of clue-num, clue tuples.) */\n  clues: Record<'Across' | 'Down', [number, string][]>;\n\n  saved?: unknown; // not supported!\n  showenumerations?: unknown; // not supported!\n  clueplacement?: unknown; // not supported!\n  enumeration?: unknown; // not supported!\n  enumerations?: unknown; // not supported!\n  misses?: unknown; // not supported!\n}\n\nconst IpuzURI = 'http://ipuz.org';\nconst IpuzVersionURI = `${IpuzURI}/v`;\nconst IpuzVersion = 2;\nconst IpuzCrosswordURI = `${IpuzURI}/crossword#`;\nconst IpuzCrosswordVersion = 1;\n\nconst directionMap = {\n  Across: 'across',\n  Down: 'down',\n} as const;\n\nexport function useIpuz(data: unknown) {\n  return useMemo(() => {\n    if (!isIpuzData(data)) {\n      // eslint-disable-next-line no-console\n      console.error('useIpuz() was not given IPUZ data');\n      return null;\n    }\n\n    if (!isSupportedIpuz(data)) {\n      // eslint-disable-next-line no-console\n      console.error('useIpuz() was not given supported IPUZ data');\n      return null;\n    }\n\n    return convertIpuz(data);\n  }, [data]);\n}\n\n/** Inspects a value to see if it looks like IPUZ data. */\nexport function isIpuzData(data: unknown): data is IpuzInput {\n  return (\n    !!data &&\n    typeof data === 'object' &&\n    'version' in data &&\n    typeof data.version === 'string' &&\n    data.version.startsWith(IpuzVersionURI)\n  );\n}\n\n/** Checks to see whether the IPUZ data is supported. */\nexport function isSupportedIpuz(ipuz: IpuzInput) {\n  const version = Number.parseInt(\n    ipuz.version.substring(IpuzVersionURI.length),\n    10\n  );\n  if (version > IpuzVersion) {\n    return false;\n  }\n  if (ipuz.kind.length !== 1 || !ipuz.kind[0].startsWith(IpuzCrosswordURI)) {\n    return false;\n  }\n  const crosswordVersion = Number.parseInt(\n    ipuz.kind[0].substring(IpuzCrosswordURI.length),\n    10\n  );\n  if (crosswordVersion > IpuzCrosswordVersion) {\n    return false;\n  }\n  return true;\n}\n\n/** Converts an IPUZ crossword to our internal format. */\nexport function convertIpuz(ipuz: IpuzInput): CluesInputOriginal {\n  // loop through the puzzle and figure out the row/col of each clue...\n  const clueLocs = ipuz.puzzle.reduce<\n    Record<string, { row: number; col: number }>\n  >(\n    (memoOuter, rowData, row) =>\n      rowData.reduce((memoInner, cell, col) => {\n        const key = typeof cell === 'object' ? cell?.cell ?? -1 : cell;\n        memoInner[key.toString()] = { row, col };\n        return memoInner;\n      }, memoOuter),\n    {}\n  );\n\n  // console.log('GOT CLUE LOCS', clueLocs);\n  const converted: CluesInputOriginal = Object.fromEntries(\n    (\n      Object.entries(ipuz.clues) as ['Across' | 'Down', [number, string][]][]\n    ).map(([dir, clueList]) => {\n      const dirClues = clueList.reduce<Record<string, ClueTypeOriginal>>(\n        (memo, [num, clueText]) => {\n          // console.log('looking for', dir, num);\n          const { row, col } = clueLocs[num.toString()];\n          // get the answer by inspecting the solution grid\n          let answer = '';\n          const dr = dir === 'Across' ? 0 : 1;\n          const dc = dir === 'Across' ? 1 : 0;\n          for (\n            let r = row, c = col;\n            r < ipuz.dimensions.height && c < ipuz.dimensions.width;\n            r += dr, c += dc\n          ) {\n            const ch = ipuz.solution[r][c];\n            if (!ch || ch === '#') {\n              break;\n            }\n            answer += ch;\n          }\n\n          memo[num.toString()] = {\n            clue: clueText,\n            answer,\n            row,\n            col,\n          };\n\n          return memo;\n        },\n        {}\n      );\n\n      return [directionMap[dir], dirClues];\n    })\n  ) as CluesInputOriginal;\n\n  return converted;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}