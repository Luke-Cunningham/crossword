{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/Users/lukecunningham/Documents/GitHub/crossword-app/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.crosswordProviderPropTypes = void 0;\nvar jsx_runtime_1 = require(\"react/jsx-runtime\");\n/* eslint-disable no-console */\nvar react_1 = __importStar(require(\"react\"));\nvar prop_types_1 = __importDefault(require(\"prop-types\"));\nvar immer_1 = __importDefault(require(\"immer\"));\nvar styled_components_1 = require(\"styled-components\");\nvar context_1 = require(\"./context\");\nvar types_1 = require(\"./types\");\nvar util_1 = require(\"./util\");\nvar defaultStorageKey = 'guesses';\nexports.crosswordProviderPropTypes = {\n  /**\n   * clue/answer data; see <a\n   * href=\"#/Configuration%20and%20customization/Clue%20input%20format\">Clue\n   * input format</a> for details.\n   */\n  data: types_1.cluesInputShapeOriginal.isRequired,\n  /** presentation values for the crossword; these override any values coming from a parent ThemeProvider context. */\n  theme: prop_types_1.default.shape({\n    /**\n     * whether to allow a non-square rendering\n     * @since 5.1.0\n     */\n    allowNonSquare: prop_types_1.default.bool,\n    /** browser-width at which the clues go from showing beneath the grid to showing beside the grid */\n    columnBreakpoint: prop_types_1.default.string,\n    /** overall background color (fill) for the crossword grid; can be `'transparent'` to show through a page background image */\n    gridBackground: prop_types_1.default.string,\n    /**  background for an answer cell */\n    cellBackground: prop_types_1.default.string,\n    /** border for an answer cell */\n    cellBorder: prop_types_1.default.string,\n    /** color for answer text (entered by the player) */\n    textColor: prop_types_1.default.string,\n    /** color for the across/down numbers in the grid */\n    numberColor: prop_types_1.default.string,\n    /** background color for the cell with focus, the one that the player is typing into */\n    focusBackground: prop_types_1.default.string,\n    /**\n     * background color for the cells in the answer the player is working on,\n     * helps indicate in which direction focus will be moving; also used as a\n     * background on the active clue\n     */\n    highlightBackground: prop_types_1.default.string\n  }),\n  /** whether to use browser storage to persist the player's work-in-progress */\n  useStorage: prop_types_1.default.bool,\n  /**\n   * a custom storage key to use for persistence; defaults to \"guesses\" when not\n   * provided\n   */\n  storageKey: prop_types_1.default.string,\n  /**\n   * callback function that fires when a player completes an answer, whether\n   * correct or not; called with `(direction, number, correct, answer)`\n   * arguments, where `direction` is `'across'` or `'down'`, `number` is the\n   * clue number as text (like `'1'`), `correct` is whether the guessed answer\n   * is correct and `answer` is the (actual and correct) answer itself\n   *\n   * @since 4.3.0\n   */\n  onAnswerComplete: prop_types_1.default.func,\n  /**\n   * callback function that fires when a player answers a clue correctly; called\n   * with `(direction, number, answer)` arguments, where `direction` is\n   * `'across'` or `'down'`, `number` is the clue number as text (like `'1'`),\n   * and `answer` is the answer itself\n   *\n   * @since 4.3.0; replacing `onCorrect` (to reduce ambiguity)\n   */\n  onAnswerCorrect: prop_types_1.default.func,\n  /**\n   * callback function that fires when a player answers a clue correctly; called\n   * with `(direction, number, answer)` arguments, where `direction` is\n   * `'across'` or `'down'`, `number` is the clue number as text (like `'1'`),\n   * and `answer` is the answer itself\n   *\n   * @deprecated 4.3.0; being replaced by `onAnswerCorrect` (to reduce\n   * ambiguity)\n   */\n  onCorrect: prop_types_1.default.func,\n  /**\n   * callback function that fires when a player answers a clue *in*correctly;\n   * called with `(direction, number, answer)` arguments, where `direction` is\n   * `'across'` or `'down'`, `number` is the clue number as text (like `'1'`),\n   * and `answer` is the (actual and correct) answer itself\n   *\n   * @since 4.3.0\n   */\n  onAnswerIncorrect: prop_types_1.default.func,\n  /**\n   * callback function that's called when a crossword is loaded, to batch up\n   * correct answers loaded from storage; passed an array of the same values\n   * that `onCorrect` would recieve\n   */\n  onLoadedCorrect: prop_types_1.default.func,\n  /**\n   * callback function that's called when the overall crossword is complete,\n   * whether correct or not; called with `(correct)` argument, a boolean which\n   * indicates whether the crossword is correct or not.\n   */\n  onCrosswordComplete: prop_types_1.default.func,\n  /**\n   * callback function that's called when the overall crossword is completely\n   * correct (or not)\n   *\n   * NOTE: this will be deprecated for `onCrosswordComplete` in the future.\n   */\n  onCrosswordCorrect: prop_types_1.default.func,\n  /**\n   * callback function called when a cell changes (e.g. when the user types a\n   * letter); called with `(row, col, char)` arguments, where the `row` and\n   * `column` are the 0-based position of the cell, and `char` is the character\n   * typed (already massaged into upper-case)\n   */\n  onCellChange: prop_types_1.default.func,\n  /**\n   * callback function called when a clue is selected\n   */\n  onClueSelected: prop_types_1.default.func,\n  children: prop_types_1.default.node\n};\nvar defaultTheme = {\n  allowNonSquare: false,\n  columnBreakpoint: '768px',\n  gridBackground: 'rgb(0,0,0)',\n  cellBackground: 'rgb(255,255,255)',\n  cellBorder: 'rgb(0,0,0)',\n  textColor: 'rgb(0,0,0)',\n  numberColor: 'rgba(0,0,0, 0.25)',\n  focusBackground: 'rgb(255,255,0)',\n  highlightBackground: 'rgb(255,255,204)'\n};\n/**\n * The fundamental logic and data management component for react-crossword.\n * Prior to 4.0, puzzle management was built into the `Crossword` component.  As\n * of 4.0, the logic implementation has been refactored such that `Crossword`\n * leverages `CrosswordProvider` to do the heavy lifting.\n *\n * @since 4.0\n */\nvar CrosswordProvider = react_1.default.forwardRef(function (_ref, ref) {\n  var data = _ref.data,\n    theme = _ref.theme,\n    onAnswerComplete = _ref.onAnswerComplete,\n    onAnswerCorrect = _ref.onAnswerCorrect,\n    onCorrect = _ref.onCorrect,\n    onAnswerIncorrect = _ref.onAnswerIncorrect,\n    onLoadedCorrect = _ref.onLoadedCorrect,\n    onCrosswordComplete = _ref.onCrosswordComplete,\n    onCrosswordCorrect = _ref.onCrosswordCorrect,\n    onCellChange = _ref.onCellChange,\n    onClueSelected = _ref.onClueSelected,\n    useStorage = _ref.useStorage,\n    storageKey = _ref.storageKey,\n    children = _ref.children;\n  var contextTheme = (0, react_1.useContext)(styled_components_1.ThemeContext);\n  // The final theme is the merger of three values: the \"theme\" property\n  // passed to the component (which takes precedence), any values from\n  // ThemeContext, and finally the \"defaultTheme\" values fill in for any\n  // needed ones that are missing.  (We create this in standard last-one-wins\n  // order in Javascript, of course.)\n  var finalTheme = (0, react_1.useMemo)(function () {\n    return Object.assign(Object.assign(Object.assign({}, defaultTheme), contextTheme), theme);\n  }, [contextTheme, theme]);\n  // The original Crossword implementation used separate state to track size\n  // and grid data, and conflated the clues-input-data-based grid data and the\n  // player input guesses.  Let's see if we can keep the clues-input and\n  // player data segregated.\n  var _ref2 = (0, react_1.useMemo)(function () {\n      var _a;\n      return (0, util_1.createGridData)(data, (_a = finalTheme.allowNonSquare) !== null && _a !== void 0 ? _a : false);\n    }, [data, finalTheme.allowNonSquare]),\n    rows = _ref2.rows,\n    cols = _ref2.cols,\n    masterGridData = _ref2.gridData,\n    masterClues = _ref2.clues;\n  var _ref3 = (0, react_1.useState)([]),\n    _ref4 = _slicedToArray(_ref3, 2),\n    gridData = _ref4[0],\n    setGridData = _ref4[1];\n  var _ref5 = (0, react_1.useState)(),\n    _ref6 = _slicedToArray(_ref5, 2),\n    clues = _ref6[0],\n    setClues = _ref6[1];\n  // We can't seem to use state to track the registeredFocusHandler, because\n  // there seems to be a delay in 'focus' being usable after it's set.  We use\n  // a Ref instead.\n  var registeredFocusHandler = (0, react_1.useRef)(null);\n  // interactive player state\n  var _ref7 = (0, react_1.useState)(false),\n    _ref8 = _slicedToArray(_ref7, 2),\n    focused = _ref8[0],\n    setFocused = _ref8[1];\n  var _ref9 = (0, react_1.useState)(0),\n    _ref10 = _slicedToArray(_ref9, 2),\n    focusedRow = _ref10[0],\n    setFocusedRow = _ref10[1]; // rename to selectedRow?\n  var _ref11 = (0, react_1.useState)(0),\n    _ref12 = _slicedToArray(_ref11, 2),\n    focusedCol = _ref12[0],\n    setFocusedCol = _ref12[1];\n  var _ref13 = (0, react_1.useState)('across'),\n    _ref14 = _slicedToArray(_ref13, 2),\n    currentDirection = _ref14[0],\n    setCurrentDirection = _ref14[1];\n  var _ref15 = (0, react_1.useState)('1'),\n    _ref16 = _slicedToArray(_ref15, 2),\n    currentNumber = _ref16[0],\n    setCurrentNumber = _ref16[1];\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  var _ref17 = (0, react_1.useState)(null),\n    _ref18 = _slicedToArray(_ref17, 2),\n    bulkChange = _ref18[0],\n    setBulkChange = _ref18[1];\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  var _ref19 = (0, react_1.useState)([]),\n    _ref20 = _slicedToArray(_ref19, 2),\n    checkQueue = _ref20[0],\n    setCheckQueue = _ref20[1];\n  // This *internal* getCellData assumes that it's only ever asked for a valid\n  // cell (one that's used).\n  var getCellData = (0, react_1.useCallback)(function (row, col) {\n    if (row >= 0 && row < rows && col >= 0 && col < cols) {\n      return gridData[row][col];\n    }\n    // fake cellData to represent \"out of bounds\"\n    return {\n      row: row,\n      col: col,\n      used: false,\n      outOfBounds: true\n    };\n  }, [cols, gridData, rows]);\n  var setCellCharacter = (0, react_1.useCallback)(function (row, col, char) {\n    var cell = getCellData(row, col);\n    if (!cell.used) {\n      throw new Error('unexpected setCellCharacter call');\n    }\n    // If the character is already the cell's guess, there's nothing to do.\n    if (cell.guess === char) {\n      return;\n    }\n    // update the gridData with the guess\n    setGridData((0, immer_1.default)(function (draft) {\n      draft[row][col].guess = char;\n    }));\n    // push the row/col for checking!\n    setCheckQueue((0, immer_1.default)(function (draft) {\n      draft.push({\n        row: row,\n        col: col\n      });\n    }));\n    if (onCellChange) {\n      onCellChange(row, col, char);\n    }\n  }, [getCellData, onCellChange]);\n  var notifyAnswerComplete = (0, react_1.useCallback)(function (direction, number, correct, answer) {\n    if (onAnswerComplete) {\n      onAnswerComplete(direction, number, correct, answer);\n    }\n    if (correct) {\n      if (onAnswerCorrect) {\n        onAnswerCorrect(direction, number, answer);\n      }\n      // NOTE: onCorrect to be (eventually) deprecated\n      if (onCorrect) {\n        onCorrect(direction, number, answer);\n      }\n    } else if (onAnswerIncorrect) {\n      onAnswerIncorrect(direction, number, answer);\n    }\n  }, [onAnswerComplete, onAnswerCorrect, onAnswerIncorrect, onCorrect]);\n  var checkCorrectness = (0, react_1.useCallback)(function (row, col) {\n    var cell = getCellData(row, col);\n    if (!cell.used) {\n      // Because this is in an internal callback, and we only call it with a\n      // valid cell (row/col), the throw line isn't testable... so we ignore\n      // it.\n      /* istanbul ignore next */\n      throw new Error('unexpected unused cell');\n    }\n    // check all the cells for both across and down answers that use this\n    // cell\n    util_1.bothDirections.forEach(function (direction) {\n      var across = (0, util_1.isAcross)(direction);\n      var number = cell[direction];\n      if (!number) {\n        return;\n      }\n      var info = data[direction][number];\n      // We send correct/incorrect messages, but *only* if every cell in the\n      // answer is filled out; there's no point in reporting \"incorrect\"\n      // when the answer is simply incomplete.\n      var complete = true;\n      var correct = true;\n      for (var i = 0; i < info.answer.length; i++) {\n        var checkCell = getCellData(info.row + (across ? 0 : i), info.col + (across ? i : 0));\n        if (!checkCell.guess) {\n          complete = false;\n          correct = false;\n          break;\n        }\n        if (checkCell.guess !== checkCell.answer) {\n          correct = false;\n        }\n      }\n      // update the clue state\n      setClues((0, immer_1.default)(function (draft) {\n        if (draft) {\n          var clueInfo = draft[direction].find(function (i) {\n            return i.number === number;\n          });\n          if (clueInfo) {\n            clueInfo.complete = complete;\n            clueInfo.correct = correct;\n          }\n        }\n      }));\n      if (complete) {\n        notifyAnswerComplete(direction, number, correct, info.answer);\n      }\n    });\n  }, [data, getCellData, notifyAnswerComplete]);\n  // Any time the checkQueue changes, call checkCorrectness!\n  (0, react_1.useEffect)(function () {\n    if (checkQueue.length === 0) {\n      return;\n    }\n    checkQueue.forEach(function (_ref21) {\n      var row = _ref21.row,\n        col = _ref21.col;\n      return checkCorrectness(row, col);\n    });\n    setCheckQueue([]);\n  }, [checkQueue, checkCorrectness]);\n  // Any time the clues change, determine if they are all complete/correct or\n  // not.\n  var _ref22 = (0, react_1.useMemo)(function () {\n      var complete = !!(clues && util_1.bothDirections.every(function (direction) {\n        return clues[direction].every(function (clueInfo) {\n          return clueInfo.complete;\n        });\n      }));\n      var correct = complete && !!(clues && util_1.bothDirections.every(function (direction) {\n        return clues[direction].every(function (clueInfo) {\n          return clueInfo.correct;\n        });\n      }));\n      // console.log('setting crossword correct', { clues, correct });\n      return {\n        crosswordComplete: complete,\n        crosswordCorrect: correct\n      };\n    }, [clues]),\n    crosswordComplete = _ref22.crosswordComplete,\n    crosswordCorrect = _ref22.crosswordCorrect;\n  // Let the consumer know everything's correct (or not) if they've asked to\n  // be informed.\n  (0, react_1.useEffect)(function () {\n    if (crosswordComplete) {\n      if (onCrosswordComplete) {\n        onCrosswordComplete(crosswordCorrect);\n      }\n      if (onCrosswordCorrect) {\n        onCrosswordCorrect(crosswordCorrect);\n      }\n    }\n  }, [crosswordComplete, crosswordCorrect, onCrosswordComplete, onCrosswordCorrect]);\n  // focus and movement\n  var focus = (0, react_1.useCallback)(function () {\n    // console.log('CrosswordProvider.focus() called...');\n    // If there's a registered focus handler, use it!\n    if (registeredFocusHandler.current) {\n      // console.log('calling registered focus handler...');\n      registeredFocusHandler.current();\n      setFocused(true);\n    } else {\n      console.warn('CrosswordProvider: focus() has no registered handler to call!');\n    }\n  }, []);\n  var moveTo = (0, react_1.useCallback)(function (row, col, directionOverride) {\n    var _a;\n    var direction = directionOverride !== null && directionOverride !== void 0 ? directionOverride : currentDirection;\n    var candidate = getCellData(row, col);\n    if (!candidate.used) {\n      return false;\n    }\n    // If we try to move to a cell with a direction it doesn't support,\n    // switch to the other direction.  There is no codepath that can test\n    // this, though, as this callback isn't exposed, and we only call it in\n    // ways that guarantee that direction is valid.\n    if (!candidate[direction]) {\n      /* istanbul ignore next */\n      direction = (0, util_1.otherDirection)(direction);\n    }\n    setFocusedRow(row);\n    setFocusedCol(col);\n    setCurrentDirection(direction);\n    setCurrentNumber((_a = candidate[direction]) !== null && _a !== void 0 ? _a : '');\n    return candidate;\n  }, [currentDirection, getCellData]);\n  var moveRelative = (0, react_1.useCallback)(function (dRow, dCol) {\n    // We expect *only* one of dRow or dCol to have a non-zero value, and\n    // that's the direction we will \"prefer\".  If *both* are set (or zero),\n    // we don't change the direction.\n    var direction;\n    if (dRow !== 0 && dCol === 0) {\n      direction = 'down';\n    } else if (dRow === 0 && dCol !== 0) {\n      direction = 'across';\n    }\n    var cell = moveTo(focusedRow + dRow, focusedCol + dCol, direction);\n    return cell;\n  }, [focusedRow, focusedCol, moveTo]);\n  var moveForward = (0, react_1.useCallback)(function () {\n    var across = (0, util_1.isAcross)(currentDirection);\n    moveRelative(across ? 0 : 1, across ? 1 : 0);\n  }, [currentDirection, moveRelative]);\n  var moveBackward = (0, react_1.useCallback)(function () {\n    var across = (0, util_1.isAcross)(currentDirection);\n    moveRelative(across ? 0 : -1, across ? -1 : 0);\n  }, [currentDirection, moveRelative]);\n  // keyboard handling\n  var handleSingleCharacter = (0, react_1.useCallback)(function (char) {\n    setCellCharacter(focusedRow, focusedCol, char.toUpperCase());\n    moveForward();\n  }, [focusedRow, focusedCol, setCellCharacter, moveForward]);\n  // We use the keydown event for control/arrow keys, but not for textual\n  // input, because it's hard to suss out when a key is \"regular\" or not.\n  var handleInputKeyDown = (0, react_1.useCallback)(function (event) {\n    var _a;\n    // if ctrl, alt, or meta are down, ignore the event (let it bubble)\n    if (event.ctrlKey || event.altKey || event.metaKey) {\n      return;\n    }\n    var preventDefault = true;\n    var key = event.key;\n    // console.log('CROSSWORD KEYDOWN', event.key);\n    // FUTURE: should we \"jump\" over black space?  That might help some for\n    // keyboard users.\n    switch (key) {\n      case 'ArrowUp':\n        moveRelative(-1, 0);\n        break;\n      case 'ArrowDown':\n        moveRelative(1, 0);\n        break;\n      case 'ArrowLeft':\n        moveRelative(0, -1);\n        break;\n      case 'ArrowRight':\n        moveRelative(0, 1);\n        break;\n      case ' ': // treat space like tab?\n      case 'Tab':\n        {\n          var other = (0, util_1.otherDirection)(currentDirection);\n          var cellData = getCellData(focusedRow, focusedCol);\n          if (cellData[other]) {\n            setCurrentDirection(other);\n            setCurrentNumber((_a = cellData[other]) !== null && _a !== void 0 ? _a : '');\n          }\n          break;\n        }\n      // Backspace: delete the current cell, and move to the previous cell\n      // Delete:    delete the current cell, but don't move\n      case 'Backspace':\n      case 'Delete':\n        {\n          setCellCharacter(focusedRow, focusedCol, '');\n          if (key === 'Backspace') {\n            moveBackward();\n          }\n          break;\n        }\n      case 'Home':\n      case 'End':\n        {\n          // move to beginning/end of this entry?\n          var info = data[currentDirection][currentNumber];\n          var length = info.answer.length;\n          var row = info.row,\n            col = info.col;\n          if (key === 'End') {\n            var across = (0, util_1.isAcross)(currentDirection);\n            if (across) {\n              col += length - 1;\n            } else {\n              row += length - 1;\n            }\n          }\n          moveTo(row, col);\n          break;\n        }\n      default:\n        // It would be nice to handle \"regular\" characters with onInput, but\n        // that is still experimental, so we can't count on it.  Instead, we\n        // assume that only \"length 1\" values are regular.\n        if (key.length !== 1) {\n          preventDefault = false;\n          break;\n        }\n        handleSingleCharacter(key);\n        break;\n    }\n    if (preventDefault) {\n      event.preventDefault();\n    }\n  }, [moveRelative, handleSingleCharacter, currentDirection, getCellData, focusedRow, focusedCol, setCellCharacter, moveBackward, data, currentNumber, moveTo]);\n  var handleInputChange = (0, react_1.useCallback)(function (event) {\n    event.preventDefault();\n    setBulkChange(event.target.value);\n  }, []);\n  (0, react_1.useEffect)(function () {\n    if (!bulkChange) {\n      return;\n    }\n    // handle bulkChange by updating a character at a time (this lets us\n    // leverage the existing character-entry logic).\n    handleSingleCharacter(bulkChange[0]);\n    setBulkChange(bulkChange.length === 1 ? null : bulkChange.substring(1));\n  }, [bulkChange, handleSingleCharacter]);\n  // When the clues *input* data changes, reset/reload the player data\n  (0, react_1.useEffect)(function () {\n    // deep-clone the grid data...\n    var newGridData = masterGridData.map(function (row) {\n      return row.map(function (cell) {\n        return Object.assign({}, cell);\n      });\n    });\n    // deep-clone the clue data...\n    var newCluesData = {\n      across: masterClues.across.map(function (clue) {\n        return Object.assign({}, clue);\n      }),\n      down: masterClues.down.map(function (clue) {\n        return Object.assign({}, clue);\n      })\n    };\n    if (useStorage) {\n      (0, util_1.loadGuesses)(newGridData, storageKey || defaultStorageKey);\n    }\n    setClues(newCluesData);\n    setGridData(newGridData);\n    // Check all of the clues to see if any were correct... but only if we\n    // loaded guesses.  Since the current implementation relies on state, we\n    // leverage the checkQueue to run through all the clues/guesses.\n    //\n    // Really, the ideal thing to do would be to write the checking-logic in a\n    // way that it doesn't assume the data is already in state... that would\n    // allow us to check everything directly, and simply set the same state\n    // that checkCorrectness() does, *and* properly call onLoadedCorrect(). As\n    // it is, this implementation can cause some answers to mentioned in\n    // onCorrect() more than once (any time an across answer starts inside a\n    // down answer, or vice versa.)\n    if (useStorage) {\n      setCheckQueue(util_1.bothDirections.flatMap(function (dir) {\n        return (\n          // simply use the row/col that starts each answer.\n          newCluesData[dir].map(function (_ref23) {\n            var row = _ref23.row,\n              col = _ref23.col;\n            return {\n              row: row,\n              col: col\n            };\n          })\n        );\n      }));\n    }\n    // Should we start with 1-across highlighted/focused?\n    // TODO: track input-field focus so we don't draw highlight when we're not\n    // really focused, *and* use first actual clue (whether across or down?)\n    setFocusedRow(0);\n    setFocusedCol(0);\n    setCurrentDirection('across');\n    setCurrentNumber('1');\n  }, [masterClues, masterGridData, storageKey, useStorage]);\n  // save the guesses any time they change...\n  (0, react_1.useEffect)(function () {\n    if (gridData === null || !useStorage) {\n      return;\n    }\n    (0, util_1.saveGuesses)(gridData, storageKey || defaultStorageKey);\n  }, [gridData, storageKey, useStorage]);\n  var handleCellClick = (0, react_1.useCallback)(function (cellData) {\n    var _a;\n    if (cellData.used) {\n      var row = cellData.row,\n        col = cellData.col;\n      var other = (0, util_1.otherDirection)(currentDirection);\n      // should this use moveTo?\n      setFocusedRow(row);\n      setFocusedCol(col);\n      var direction = currentDirection;\n      // We switch to the \"other\" direction if (a) the current direction\n      // isn't available in the clicked cell, or (b) we're already focused\n      // and the clicked cell is the focused cell, *and* the other direction\n      // is available.\n      if (!cellData[currentDirection] || focused && row === focusedRow && col === focusedCol && cellData[other]) {\n        setCurrentDirection(other);\n        direction = other;\n      }\n      setCurrentNumber((_a = cellData[direction]) !== null && _a !== void 0 ? _a : '');\n    }\n    focus();\n  }, [currentDirection, focus, focused, focusedCol, focusedRow]);\n  var handleInputClick = (0, react_1.useCallback)(function /* event */\n  () {\n    // *don't* event.preventDefault(), because we want the input to actually\n    // take focus\n    var _a;\n    // Like general cell-clicks, cliking on the input can change direction.\n    // Unlike cell clicks, we *know* we're clicking on the already-focused\n    // cell!\n    var other = (0, util_1.otherDirection)(currentDirection);\n    var cellData = getCellData(focusedRow, focusedCol);\n    var direction = currentDirection;\n    if (focused && cellData[other]) {\n      setCurrentDirection(other);\n      direction = other;\n    }\n    setCurrentNumber((_a = cellData[direction]) !== null && _a !== void 0 ? _a : '');\n    focus();\n  }, [currentDirection, focus, focused, focusedCol, focusedRow, getCellData]);\n  var handleClueSelected = (0, react_1.useCallback)(function (direction, number) {\n    var info = clues === null || clues === void 0 ? void 0 : clues[direction].find(function (clue) {\n      return clue.number === number;\n    });\n    if (!info) {\n      return;\n    }\n    // console.log('CrosswordProvider.handleClueSelected', { info });\n    // TODO: sanity-check info?\n    moveTo(info.row, info.col, direction);\n    focus();\n    if (onClueSelected) {\n      onClueSelected(direction, number);\n    }\n  }, [clues, focus, moveTo, onClueSelected]);\n  var registerFocusHandler = (0, react_1.useCallback)(function (focusHandler) {\n    // console.log('CrosswordProvider.registerFocusHandler() called', {\n    //   name: focusHandler?.name ?? '(NULL)',\n    //   focusHandler,\n    // });\n    // *If* registeredFocusHandler is implemented as state, realize that we\n    // can't simply pass it to the setter... the useState React setter would\n    // *invoke* the function and take the return value!  So, we would have\n    // to wrap it in a functional setter (setState(() => focusHandler)).\n    // But, since we're using a Ref, this is just a simple assignment!\n    registeredFocusHandler.current = focusHandler;\n  }, []);\n  // imperative commands...\n  (0, react_1.useImperativeHandle)(ref, function () {\n    return {\n      /**\n       * Sets focus to the crossword component.\n       */\n      focus: focus,\n      /**\n       * Resets the entire crossword; clearing all answers in the grid and\n       * also any persisted data.\n       */\n      reset: function reset() {\n        setGridData((0, immer_1.default)(function (draft) {\n          draft.forEach(function (rowData) {\n            rowData.forEach(function (cellData) {\n              if (cellData.used) {\n                cellData.guess = '';\n              }\n            });\n          });\n        }));\n        setClues((0, immer_1.default)(function (draft) {\n          util_1.bothDirections.forEach(function (direction) {\n            var _a;\n            (_a = draft === null || draft === void 0 ? void 0 : draft[direction]) === null || _a === void 0 ? void 0 : _a.forEach(function (clueInfo) {\n              delete clueInfo.complete;\n              delete clueInfo.correct;\n            });\n          });\n        }));\n        if (useStorage) {\n          (0, util_1.clearGuesses)(storageKey || defaultStorageKey);\n        }\n      },\n      /**\n       * Fills all the answers in the grid and calls the `onLoadedCorrect`\n       * callback with _**every**_ answer.\n       */\n      fillAllAnswers: function fillAllAnswers() {\n        setGridData((0, immer_1.default)(function (draft) {\n          draft.forEach(function (rowData) {\n            rowData.forEach(function (cellData) {\n              if (cellData.used) {\n                cellData.guess = cellData.answer;\n              }\n            });\n          });\n        }));\n        setClues((0, immer_1.default)(function (draft) {\n          util_1.bothDirections.forEach(function (direction) {\n            draft === null || draft === void 0 ? void 0 : draft[direction].forEach(function (clueInfo) {\n              clueInfo.complete = true;\n              clueInfo.correct = true;\n            });\n          });\n        }));\n        // trigger onLoadedCorrect with every clue!\n        if (onLoadedCorrect) {\n          var loadedCorrect = [];\n          util_1.bothDirections.forEach(function (direction) {\n            clues === null || clues === void 0 ? void 0 : clues[direction].forEach(function (_ref24) {\n              var number = _ref24.number,\n                answer = _ref24.answer;\n              loadedCorrect.push([direction, number, answer]);\n            });\n          });\n          onLoadedCorrect(loadedCorrect);\n        }\n      },\n      /**\n       * Returns whether the crossword is entirely correct or not.\n       */\n      isCrosswordCorrect: function isCrosswordCorrect() {\n        return crosswordCorrect;\n      },\n      /**\n       * Sets the “guess” character for a specific grid position.\n       *\n       * @since 4.1.0\n       */\n      setGuess: function setGuess(row, col, guess) {\n        // REVIEW: should we force-case this?\n        setCellCharacter(row, col, guess.toUpperCase());\n      }\n    };\n  }, [clues, crosswordCorrect, focus, onLoadedCorrect, setCellCharacter, storageKey, useStorage]);\n  var crosswordContext = (0, react_1.useMemo)(function () {\n    return {\n      rows: rows,\n      cols: cols,\n      gridData: gridData,\n      clues: clues,\n      handleInputKeyDown: handleInputKeyDown,\n      handleInputChange: handleInputChange,\n      handleCellClick: handleCellClick,\n      handleInputClick: handleInputClick,\n      handleClueSelected: handleClueSelected,\n      registerFocusHandler: registerFocusHandler,\n      focused: focused,\n      selectedPosition: {\n        row: focusedRow,\n        col: focusedCol\n      },\n      selectedDirection: currentDirection,\n      selectedNumber: currentNumber,\n      crosswordCorrect: crosswordCorrect\n    };\n  }, [rows, cols, gridData, clues, handleInputKeyDown, handleInputChange, handleCellClick, handleInputClick, handleClueSelected, registerFocusHandler, focused, focusedRow, focusedCol, currentDirection, currentNumber, crosswordCorrect]);\n  return (0, jsx_runtime_1.jsx)(styled_components_1.ThemeProvider, Object.assign({\n    theme: finalTheme\n  }, {\n    children: (0, jsx_runtime_1.jsx)(context_1.CrosswordContext.Provider, Object.assign({\n      value: crosswordContext\n    }, {\n      children: children\n    }))\n  }));\n});\nexports.default = CrosswordProvider;\nCrosswordProvider.displayName = 'CrosswordProvider';\nCrosswordProvider.propTypes = exports.crosswordProviderPropTypes;\nCrosswordProvider.defaultProps = {\n  theme: undefined,\n  useStorage: true,\n  storageKey: undefined,\n  onAnswerComplete: undefined,\n  onAnswerCorrect: undefined,\n  onCorrect: undefined,\n  onAnswerIncorrect: undefined,\n  onLoadedCorrect: undefined,\n  onCrosswordComplete: undefined,\n  onCrosswordCorrect: undefined,\n  onCellChange: undefined,\n  onClueSelected: undefined,\n  children: undefined\n};","map":{"version":3,"names":["react_1","__importStar","require","prop_types_1","__importDefault","immer_1","styled_components_1","context_1","types_1","util_1","defaultStorageKey","exports","crosswordProviderPropTypes","data","cluesInputShapeOriginal","isRequired","theme","default","shape","allowNonSquare","bool","columnBreakpoint","string","gridBackground","cellBackground","cellBorder","textColor","numberColor","focusBackground","highlightBackground","useStorage","storageKey","onAnswerComplete","func","onAnswerCorrect","onCorrect","onAnswerIncorrect","onLoadedCorrect","onCrosswordComplete","onCrosswordCorrect","onCellChange","onClueSelected","children","node","defaultTheme","CrosswordProvider","forwardRef","_ref","ref","contextTheme","useContext","ThemeContext","finalTheme","useMemo","Object","assign","_ref2","_a","createGridData","rows","cols","masterGridData","gridData","masterClues","clues","_ref3","useState","_ref4","_slicedToArray","setGridData","_ref5","_ref6","setClues","registeredFocusHandler","useRef","_ref7","_ref8","focused","setFocused","_ref9","_ref10","focusedRow","setFocusedRow","_ref11","_ref12","focusedCol","setFocusedCol","_ref13","_ref14","currentDirection","setCurrentDirection","_ref15","_ref16","currentNumber","setCurrentNumber","_ref17","_ref18","bulkChange","setBulkChange","_ref19","_ref20","checkQueue","setCheckQueue","getCellData","useCallback","row","col","used","outOfBounds","setCellCharacter","char","cell","Error","guess","draft","push","notifyAnswerComplete","direction","number","correct","answer","checkCorrectness","bothDirections","forEach","across","isAcross","info","complete","i","length","checkCell","clueInfo","find","useEffect","_ref21","_ref22","every","crosswordComplete","crosswordCorrect","focus","current","console","warn","moveTo","directionOverride","candidate","otherDirection","moveRelative","dRow","dCol","moveForward","moveBackward","handleSingleCharacter","toUpperCase","handleInputKeyDown","event","ctrlKey","altKey","metaKey","preventDefault","key","other","cellData","handleInputChange","target","value","substring","newGridData","map","newCluesData","clue","down","loadGuesses","flatMap","dir","_ref23","saveGuesses","handleCellClick","handleInputClick","handleClueSelected","registerFocusHandler","focusHandler","useImperativeHandle","reset","rowData","clearGuesses","fillAllAnswers","loadedCorrect","_ref24","isCrosswordCorrect","setGuess","crosswordContext","selectedPosition","selectedDirection","selectedNumber","jsx_runtime_1","jsx","ThemeProvider","CrosswordContext","Provider","displayName","propTypes","defaultProps","undefined"],"sources":["/Users/lukecunningham/Documents/GitHub/crossword-app/node_modules/@jaredreisinger/react-crossword/src/CrosswordProvider.tsx"],"sourcesContent":["/* eslint-disable no-console */\n\nimport React, {\n  useCallback,\n  useContext,\n  useEffect,\n  useImperativeHandle,\n  useMemo,\n  useRef,\n  useState,\n} from 'react';\nimport PropTypes from 'prop-types';\n\nimport produce from 'immer';\nimport { ThemeContext, ThemeProvider } from 'styled-components';\n\nimport { CrosswordContext, CrosswordContextType } from './context';\nimport {\n  AnswerTuple,\n  CluesData,\n  CluesInput,\n  cluesInputShapeOriginal,\n  Direction,\n  EnhancedProps,\n  FocusHandler,\n  GridPosition,\n  GridData,\n  UsedCellData,\n  CellData,\n  UnusedCellData,\n} from './types';\nimport {\n  bothDirections,\n  clearGuesses,\n  createGridData,\n  isAcross,\n  loadGuesses,\n  otherDirection,\n  saveGuesses,\n} from './util';\n\nconst defaultStorageKey = 'guesses';\n\nexport const crosswordProviderPropTypes = {\n  /**\n   * clue/answer data; see <a\n   * href=\"#/Configuration%20and%20customization/Clue%20input%20format\">Clue\n   * input format</a> for details.\n   */\n  data: cluesInputShapeOriginal.isRequired,\n\n  /** presentation values for the crossword; these override any values coming from a parent ThemeProvider context. */\n  theme: PropTypes.shape({\n    /**\n     * whether to allow a non-square rendering\n     * @since 5.1.0\n     */\n    allowNonSquare: PropTypes.bool,\n\n    /** browser-width at which the clues go from showing beneath the grid to showing beside the grid */\n    columnBreakpoint: PropTypes.string,\n\n    /** overall background color (fill) for the crossword grid; can be `'transparent'` to show through a page background image */\n    gridBackground: PropTypes.string,\n    /**  background for an answer cell */\n    cellBackground: PropTypes.string,\n    /** border for an answer cell */\n    cellBorder: PropTypes.string,\n    /** color for answer text (entered by the player) */\n    textColor: PropTypes.string,\n    /** color for the across/down numbers in the grid */\n    numberColor: PropTypes.string,\n    /** background color for the cell with focus, the one that the player is typing into */\n    focusBackground: PropTypes.string,\n    /**\n     * background color for the cells in the answer the player is working on,\n     * helps indicate in which direction focus will be moving; also used as a\n     * background on the active clue\n     */\n    highlightBackground: PropTypes.string,\n  }),\n\n  /** whether to use browser storage to persist the player's work-in-progress */\n  useStorage: PropTypes.bool,\n\n  /**\n   * a custom storage key to use for persistence; defaults to \"guesses\" when not\n   * provided\n   */\n  storageKey: PropTypes.string,\n\n  /**\n   * callback function that fires when a player completes an answer, whether\n   * correct or not; called with `(direction, number, correct, answer)`\n   * arguments, where `direction` is `'across'` or `'down'`, `number` is the\n   * clue number as text (like `'1'`), `correct` is whether the guessed answer\n   * is correct and `answer` is the (actual and correct) answer itself\n   *\n   * @since 4.3.0\n   */\n  onAnswerComplete: PropTypes.func,\n\n  /**\n   * callback function that fires when a player answers a clue correctly; called\n   * with `(direction, number, answer)` arguments, where `direction` is\n   * `'across'` or `'down'`, `number` is the clue number as text (like `'1'`),\n   * and `answer` is the answer itself\n   *\n   * @since 4.3.0; replacing `onCorrect` (to reduce ambiguity)\n   */\n  onAnswerCorrect: PropTypes.func,\n\n  /**\n   * callback function that fires when a player answers a clue correctly; called\n   * with `(direction, number, answer)` arguments, where `direction` is\n   * `'across'` or `'down'`, `number` is the clue number as text (like `'1'`),\n   * and `answer` is the answer itself\n   *\n   * @deprecated 4.3.0; being replaced by `onAnswerCorrect` (to reduce\n   * ambiguity)\n   */\n  onCorrect: PropTypes.func,\n\n  /**\n   * callback function that fires when a player answers a clue *in*correctly;\n   * called with `(direction, number, answer)` arguments, where `direction` is\n   * `'across'` or `'down'`, `number` is the clue number as text (like `'1'`),\n   * and `answer` is the (actual and correct) answer itself\n   *\n   * @since 4.3.0\n   */\n  onAnswerIncorrect: PropTypes.func,\n\n  /**\n   * callback function that's called when a crossword is loaded, to batch up\n   * correct answers loaded from storage; passed an array of the same values\n   * that `onCorrect` would recieve\n   */\n  onLoadedCorrect: PropTypes.func,\n\n  /**\n   * callback function that's called when the overall crossword is complete,\n   * whether correct or not; called with `(correct)` argument, a boolean which\n   * indicates whether the crossword is correct or not.\n   */\n  onCrosswordComplete: PropTypes.func,\n\n  /**\n   * callback function that's called when the overall crossword is completely\n   * correct (or not)\n   *\n   * NOTE: this will be deprecated for `onCrosswordComplete` in the future.\n   */\n  onCrosswordCorrect: PropTypes.func,\n\n  /**\n   * callback function called when a cell changes (e.g. when the user types a\n   * letter); called with `(row, col, char)` arguments, where the `row` and\n   * `column` are the 0-based position of the cell, and `char` is the character\n   * typed (already massaged into upper-case)\n   */\n  onCellChange: PropTypes.func,\n\n  /**\n   * callback function called when a clue is selected\n   */\n  onClueSelected: PropTypes.func,\n\n  children: PropTypes.node,\n};\n\nexport type CrosswordProviderProps = EnhancedProps<\n  typeof crosswordProviderPropTypes,\n  {\n    /**\n     * clue/answer data; see <a\n     * href=\"#/Configuration%20and%20customization/Clue%20input%20format\">Clue\n     * input format</a> for details.\n     */\n    data: CluesInput;\n\n    /**\n     * callback function that fires when a player completes an answer, whether\n     * correct or not; called with `(direction, number, correct, answer)`\n     * arguments, where `direction` is `'across'` or `'down'`, `number` is the\n     * clue number as text (like `'1'`), `correct` is whether the guessed answer\n     * is correct and `answer` is the (actual and correct) answer itself\n     *\n     * @since 4.3.0\n     */\n    onAnswerComplete?: (\n      direction: Direction,\n      number: string,\n      correct: boolean,\n      answer: string\n    ) => void;\n\n    /**\n     * callback function that fires when a player answers a clue correctly;\n     * called with `(direction, number, answer)` arguments, where `direction` is\n     * `'across'` or `'down'`, `number` is the clue number as text (like `'1'`),\n     * and `answer` is the answer itself\n     *\n     * @since 4.3.0; replacing `onCorrect` (to reduce ambiguity)\n     */\n    onAnswerCorrect?: (\n      direction: Direction,\n      number: string,\n      answer: string\n    ) => void;\n\n    /**\n     * callback function that fires when a player answers a clue correctly;\n     * called with `(direction, number, answer)` arguments, where `direction` is\n     * `'across'` or `'down'`, `number` is the clue number as text (like `'1'`),\n     * and `answer` is the answer itself\n     *\n     * NOTE: this is the original/previous name for what is now being called\n     * `onAnswerCorrect` (to reduce ambiguity).  It will be deprecated in the\n     * future.\n     */\n    onCorrect?: (direction: Direction, number: string, answer: string) => void;\n\n    /**\n     * callback function that fires when a player answers a clue *in*correctly;\n     * called with `(direction, number, answer)` arguments, where `direction` is\n     * `'across'` or `'down'`, `number` is the clue number as text (like `'1'`),\n     * and `answer` is the (actual and correct) answer itself\n     *\n     * @since 4.3.0\n     */\n    onAnswerIncorrect?: (\n      direction: Direction,\n      number: string,\n      answer: string\n    ) => void;\n\n    /**\n     * callback function that's called when a crossword is loaded, to batch up\n     * correct answers loaded from storage; passed an array of the same values\n     * that `onCorrect` would recieve\n     */\n    onLoadedCorrect?: (loaded: AnswerTuple[]) => void;\n\n    /**\n     * callback function that's called when the overall crossword is complete,\n     * whether correct or not; called with `(correct)` argument, a boolean which\n     * indicates whether the crossword is correct or not.\n     */\n    onCrosswordComplete?: (correct: boolean) => void;\n\n    /**\n     * callback function that's called when the overall crossword is completely\n     * correct (or not)\n     *\n     * NOTE: this will be deprecated for `onCrosswordComplete` in the future.\n     */\n    onCrosswordCorrect?: (isCorrect: boolean) => void;\n\n    /**\n     * callback function called when a cell changes (e.g. when the user types a\n     * letter); called with `(row, col, char)` arguments, where the `row` and\n     * `column` are the 0-based position of the cell, and `char` is the\n     * character typed (already massaged into upper-case)\n     */\n    onCellChange?: (row: number, col: number, char: string) => void;\n\n    /**\n     * callback function called when a clue is selected\n     */\n    onClueSelected?: (direction: Direction, number: string) => void;\n  }\n>;\n\nexport interface CrosswordProviderImperative {\n  /**\n   * Sets focus to the crossword component.\n   */\n  focus: () => void;\n\n  /**\n   * Resets the entire crossword; clearing all answers in the grid and\n   * also any persisted data.\n   */\n  reset: () => void;\n\n  /**\n   * Fills all the answers in the grid and calls the `onLoadedCorrect`\n   * callback with _**every**_ answer.\n   */\n  fillAllAnswers: () => void;\n\n  /**\n   * Returns whether the crossword is entirely correct or not.\n   */\n  isCrosswordCorrect: () => boolean;\n\n  /**\n   * Sets the “guess” character for a specific grid position.\n   *\n   * @since 4.1.0\n   */\n  setGuess: (row: number, col: number, guess: string) => void;\n}\n\nconst defaultTheme: CrosswordProviderProps['theme'] = {\n  allowNonSquare: false,\n  columnBreakpoint: '768px',\n  gridBackground: 'rgb(0,0,0)',\n  cellBackground: 'rgb(255,255,255)',\n  cellBorder: 'rgb(0,0,0)',\n  textColor: 'rgb(0,0,0)',\n  numberColor: 'rgba(0,0,0, 0.25)',\n  focusBackground: 'rgb(255,255,0)',\n  highlightBackground: 'rgb(255,255,204)',\n};\n\n/**\n * The fundamental logic and data management component for react-crossword.\n * Prior to 4.0, puzzle management was built into the `Crossword` component.  As\n * of 4.0, the logic implementation has been refactored such that `Crossword`\n * leverages `CrosswordProvider` to do the heavy lifting.\n *\n * @since 4.0\n */\nconst CrosswordProvider = React.forwardRef<\n  CrosswordProviderImperative,\n  CrosswordProviderProps\n>(\n  (\n    {\n      data,\n      theme,\n      onAnswerComplete,\n      onAnswerCorrect,\n      onCorrect,\n      onAnswerIncorrect,\n      onLoadedCorrect,\n      onCrosswordComplete,\n      onCrosswordCorrect,\n      onCellChange,\n      onClueSelected,\n      useStorage,\n      storageKey,\n      children,\n    },\n    ref\n  ) => {\n    const contextTheme =\n      useContext<CrosswordProviderProps['theme']>(ThemeContext);\n\n    // The final theme is the merger of three values: the \"theme\" property\n    // passed to the component (which takes precedence), any values from\n    // ThemeContext, and finally the \"defaultTheme\" values fill in for any\n    // needed ones that are missing.  (We create this in standard last-one-wins\n    // order in Javascript, of course.)\n    const finalTheme = useMemo(\n      () => ({ ...defaultTheme, ...contextTheme, ...theme }),\n      [contextTheme, theme]\n    );\n\n    // The original Crossword implementation used separate state to track size\n    // and grid data, and conflated the clues-input-data-based grid data and the\n    // player input guesses.  Let's see if we can keep the clues-input and\n    // player data segregated.\n    const {\n      rows,\n      cols,\n      gridData: masterGridData,\n      clues: masterClues,\n    } = useMemo(\n      () => createGridData(data, finalTheme.allowNonSquare ?? false),\n      [data, finalTheme.allowNonSquare]\n    );\n\n    const [gridData, setGridData] = useState<GridData>([]);\n    const [clues, setClues] = useState<CluesData | undefined>();\n\n    // We can't seem to use state to track the registeredFocusHandler, because\n    // there seems to be a delay in 'focus' being usable after it's set.  We use\n    // a Ref instead.\n    const registeredFocusHandler = useRef<FocusHandler | null>(null);\n\n    // interactive player state\n    const [focused, setFocused] = useState(false);\n    const [focusedRow, setFocusedRow] = useState(0); // rename to selectedRow?\n    const [focusedCol, setFocusedCol] = useState(0);\n    const [currentDirection, setCurrentDirection] =\n      useState<Direction>('across');\n    const [currentNumber, setCurrentNumber] = useState('1');\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const [bulkChange, setBulkChange] = useState<string | null>(null);\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const [checkQueue, setCheckQueue] = useState<GridPosition[]>([]);\n\n    // This *internal* getCellData assumes that it's only ever asked for a valid\n    // cell (one that's used).\n    const getCellData = useCallback(\n      (row: number, col: number) => {\n        if (row >= 0 && row < rows && col >= 0 && col < cols) {\n          return gridData[row][col];\n        }\n\n        // fake cellData to represent \"out of bounds\"\n        return { row, col, used: false, outOfBounds: true } as GridPosition &\n          UnusedCellData;\n      },\n      [cols, gridData, rows]\n    );\n\n    const setCellCharacter = useCallback(\n      (row: number, col: number, char: string) => {\n        const cell = getCellData(row, col);\n\n        if (!cell.used) {\n          throw new Error('unexpected setCellCharacter call');\n        }\n\n        // If the character is already the cell's guess, there's nothing to do.\n        if (cell.guess === char) {\n          return;\n        }\n\n        // update the gridData with the guess\n        setGridData(\n          produce((draft) => {\n            (draft[row][col] as UsedCellData).guess = char;\n          })\n        );\n\n        // push the row/col for checking!\n        setCheckQueue(\n          produce((draft) => {\n            draft.push({ row, col });\n          })\n        );\n\n        if (onCellChange) {\n          onCellChange(row, col, char);\n        }\n      },\n      [getCellData, onCellChange]\n    );\n\n    const notifyAnswerComplete = useCallback(\n      (\n        direction: Direction,\n        number: string,\n        correct: boolean,\n        answer: string\n      ) => {\n        if (onAnswerComplete) {\n          onAnswerComplete(direction, number, correct, answer);\n        }\n\n        if (correct) {\n          if (onAnswerCorrect) {\n            onAnswerCorrect(direction, number, answer);\n          }\n\n          // NOTE: onCorrect to be (eventually) deprecated\n          if (onCorrect) {\n            onCorrect(direction, number, answer);\n          }\n        } else if (onAnswerIncorrect) {\n          onAnswerIncorrect(direction, number, answer);\n        }\n      },\n      [onAnswerComplete, onAnswerCorrect, onAnswerIncorrect, onCorrect]\n    );\n\n    const checkCorrectness = useCallback(\n      (row: number, col: number) => {\n        const cell = getCellData(row, col);\n        if (!cell.used) {\n          // Because this is in an internal callback, and we only call it with a\n          // valid cell (row/col), the throw line isn't testable... so we ignore\n          // it.\n          /* istanbul ignore next */\n          throw new Error('unexpected unused cell');\n        }\n\n        // check all the cells for both across and down answers that use this\n        // cell\n        bothDirections.forEach((direction) => {\n          const across = isAcross(direction);\n          const number = cell[direction];\n          if (!number) {\n            return;\n          }\n\n          const info = data[direction][number];\n\n          // We send correct/incorrect messages, but *only* if every cell in the\n          // answer is filled out; there's no point in reporting \"incorrect\"\n          // when the answer is simply incomplete.\n          let complete = true;\n          let correct = true;\n\n          for (let i = 0; i < info.answer.length; i++) {\n            const checkCell = getCellData(\n              info.row + (across ? 0 : i),\n              info.col + (across ? i : 0)\n            ) as UsedCellData;\n\n            if (!checkCell.guess) {\n              complete = false;\n              correct = false;\n              break;\n            }\n\n            if (checkCell.guess !== checkCell.answer) {\n              correct = false;\n            }\n          }\n\n          // update the clue state\n          setClues(\n            produce((draft) => {\n              if (draft) {\n                const clueInfo = draft[direction].find(\n                  (i) => i.number === number\n                );\n                if (clueInfo) {\n                  clueInfo.complete = complete;\n                  clueInfo.correct = correct;\n                }\n              }\n            })\n          );\n\n          if (complete) {\n            notifyAnswerComplete(direction, number, correct, info.answer);\n          }\n        });\n      },\n      [data, getCellData, notifyAnswerComplete]\n    );\n\n    // Any time the checkQueue changes, call checkCorrectness!\n    useEffect(() => {\n      if (checkQueue.length === 0) {\n        return;\n      }\n\n      checkQueue.forEach(({ row, col }) => checkCorrectness(row, col));\n      setCheckQueue([]);\n    }, [checkQueue, checkCorrectness]);\n\n    // Any time the clues change, determine if they are all complete/correct or\n    // not.\n    const { crosswordComplete, crosswordCorrect } = useMemo(() => {\n      const complete = !!(\n        clues &&\n        bothDirections.every((direction) =>\n          clues[direction].every((clueInfo) => clueInfo.complete)\n        )\n      );\n\n      const correct =\n        complete &&\n        !!(\n          clues &&\n          bothDirections.every((direction) =>\n            clues[direction].every((clueInfo) => clueInfo.correct)\n          )\n        );\n      // console.log('setting crossword correct', { clues, correct });\n      return { crosswordComplete: complete, crosswordCorrect: correct };\n    }, [clues]);\n\n    // Let the consumer know everything's correct (or not) if they've asked to\n    // be informed.\n    useEffect(() => {\n      if (crosswordComplete) {\n        if (onCrosswordComplete) {\n          onCrosswordComplete(crosswordCorrect);\n        }\n        if (onCrosswordCorrect) {\n          onCrosswordCorrect(crosswordCorrect);\n        }\n      }\n    }, [\n      crosswordComplete,\n      crosswordCorrect,\n      onCrosswordComplete,\n      onCrosswordCorrect,\n    ]);\n\n    // focus and movement\n    const focus = useCallback(() => {\n      // console.log('CrosswordProvider.focus() called...');\n\n      // If there's a registered focus handler, use it!\n      if (registeredFocusHandler.current) {\n        // console.log('calling registered focus handler...');\n        registeredFocusHandler.current();\n        setFocused(true);\n      } else {\n        console.warn(\n          'CrosswordProvider: focus() has no registered handler to call!'\n        );\n      }\n    }, []);\n\n    const moveTo = useCallback(\n      (row: number, col: number, directionOverride?: Direction) => {\n        let direction = directionOverride ?? currentDirection;\n        const candidate = getCellData(row, col);\n\n        if (!candidate.used) {\n          return false;\n        }\n\n        // If we try to move to a cell with a direction it doesn't support,\n        // switch to the other direction.  There is no codepath that can test\n        // this, though, as this callback isn't exposed, and we only call it in\n        // ways that guarantee that direction is valid.\n        if (!candidate[direction]) {\n          /* istanbul ignore next */\n          direction = otherDirection(direction);\n        }\n\n        setFocusedRow(row);\n        setFocusedCol(col);\n        setCurrentDirection(direction);\n        setCurrentNumber(candidate[direction] ?? '');\n\n        return candidate;\n      },\n      [currentDirection, getCellData]\n    );\n\n    const moveRelative = useCallback(\n      (dRow: number, dCol: number) => {\n        // We expect *only* one of dRow or dCol to have a non-zero value, and\n        // that's the direction we will \"prefer\".  If *both* are set (or zero),\n        // we don't change the direction.\n        let direction: Direction | undefined;\n        if (dRow !== 0 && dCol === 0) {\n          direction = 'down';\n        } else if (dRow === 0 && dCol !== 0) {\n          direction = 'across';\n        }\n\n        const cell = moveTo(focusedRow + dRow, focusedCol + dCol, direction);\n\n        return cell;\n      },\n      [focusedRow, focusedCol, moveTo]\n    );\n\n    const moveForward = useCallback(() => {\n      const across = isAcross(currentDirection);\n      moveRelative(across ? 0 : 1, across ? 1 : 0);\n    }, [currentDirection, moveRelative]);\n\n    const moveBackward = useCallback(() => {\n      const across = isAcross(currentDirection);\n      moveRelative(across ? 0 : -1, across ? -1 : 0);\n    }, [currentDirection, moveRelative]);\n\n    // keyboard handling\n    const handleSingleCharacter = useCallback(\n      (char: string) => {\n        setCellCharacter(focusedRow, focusedCol, char.toUpperCase());\n        moveForward();\n      },\n      [focusedRow, focusedCol, setCellCharacter, moveForward]\n    );\n\n    // We use the keydown event for control/arrow keys, but not for textual\n    // input, because it's hard to suss out when a key is \"regular\" or not.\n    const handleInputKeyDown = useCallback<\n      React.KeyboardEventHandler<HTMLInputElement>\n    >(\n      (event) => {\n        // if ctrl, alt, or meta are down, ignore the event (let it bubble)\n        if (event.ctrlKey || event.altKey || event.metaKey) {\n          return;\n        }\n\n        let preventDefault = true;\n        const { key } = event;\n        // console.log('CROSSWORD KEYDOWN', event.key);\n\n        // FUTURE: should we \"jump\" over black space?  That might help some for\n        // keyboard users.\n        switch (key) {\n          case 'ArrowUp':\n            moveRelative(-1, 0);\n            break;\n\n          case 'ArrowDown':\n            moveRelative(1, 0);\n            break;\n\n          case 'ArrowLeft':\n            moveRelative(0, -1);\n            break;\n\n          case 'ArrowRight':\n            moveRelative(0, 1);\n            break;\n\n          case ' ': // treat space like tab?\n          case 'Tab': {\n            const other = otherDirection(currentDirection);\n            const cellData = getCellData(\n              focusedRow,\n              focusedCol\n            ) as UsedCellData;\n            if (cellData[other]) {\n              setCurrentDirection(other);\n              setCurrentNumber(cellData[other] ?? '');\n            }\n            break;\n          }\n\n          // Backspace: delete the current cell, and move to the previous cell\n          // Delete:    delete the current cell, but don't move\n          case 'Backspace':\n          case 'Delete': {\n            setCellCharacter(focusedRow, focusedCol, '');\n            if (key === 'Backspace') {\n              moveBackward();\n            }\n            break;\n          }\n\n          case 'Home':\n          case 'End': {\n            // move to beginning/end of this entry?\n            const info = data[currentDirection][currentNumber];\n            const {\n              answer: { length },\n            } = info;\n            let { row, col } = info;\n            if (key === 'End') {\n              const across = isAcross(currentDirection);\n              if (across) {\n                col += length - 1;\n              } else {\n                row += length - 1;\n              }\n            }\n\n            moveTo(row, col);\n            break;\n          }\n\n          default:\n            // It would be nice to handle \"regular\" characters with onInput, but\n            // that is still experimental, so we can't count on it.  Instead, we\n            // assume that only \"length 1\" values are regular.\n            if (key.length !== 1) {\n              preventDefault = false;\n              break;\n            }\n\n            handleSingleCharacter(key);\n            break;\n        }\n\n        if (preventDefault) {\n          event.preventDefault();\n        }\n      },\n      [\n        moveRelative,\n        handleSingleCharacter,\n        currentDirection,\n        getCellData,\n        focusedRow,\n        focusedCol,\n        setCellCharacter,\n        moveBackward,\n        data,\n        currentNumber,\n        moveTo,\n      ]\n    );\n\n    const handleInputChange = useCallback<\n      React.ChangeEventHandler<HTMLInputElement>\n    >((event) => {\n      event.preventDefault();\n      setBulkChange(event.target.value);\n    }, []);\n\n    useEffect(() => {\n      if (!bulkChange) {\n        return;\n      }\n\n      // handle bulkChange by updating a character at a time (this lets us\n      // leverage the existing character-entry logic).\n      handleSingleCharacter(bulkChange[0]);\n      setBulkChange(bulkChange.length === 1 ? null : bulkChange.substring(1));\n    }, [bulkChange, handleSingleCharacter]);\n\n    // When the clues *input* data changes, reset/reload the player data\n    useEffect(() => {\n      // deep-clone the grid data...\n      const newGridData = masterGridData.map((row) =>\n        row.map((cell) => ({ ...cell }))\n      );\n\n      // deep-clone the clue data...\n      const newCluesData: CluesData = {\n        across: masterClues.across.map((clue) => ({ ...clue })),\n        down: masterClues.down.map((clue) => ({ ...clue })),\n      };\n\n      if (useStorage) {\n        loadGuesses(newGridData, storageKey || defaultStorageKey);\n      }\n\n      setClues(newCluesData);\n      setGridData(newGridData);\n\n      // Check all of the clues to see if any were correct... but only if we\n      // loaded guesses.  Since the current implementation relies on state, we\n      // leverage the checkQueue to run through all the clues/guesses.\n      //\n      // Really, the ideal thing to do would be to write the checking-logic in a\n      // way that it doesn't assume the data is already in state... that would\n      // allow us to check everything directly, and simply set the same state\n      // that checkCorrectness() does, *and* properly call onLoadedCorrect(). As\n      // it is, this implementation can cause some answers to mentioned in\n      // onCorrect() more than once (any time an across answer starts inside a\n      // down answer, or vice versa.)\n      if (useStorage) {\n        setCheckQueue(\n          bothDirections.flatMap((dir) =>\n            // simply use the row/col that starts each answer.\n            newCluesData[dir].map(({ row, col }) => ({ row, col }))\n          )\n        );\n      }\n\n      // Should we start with 1-across highlighted/focused?\n\n      // TODO: track input-field focus so we don't draw highlight when we're not\n      // really focused, *and* use first actual clue (whether across or down?)\n      setFocusedRow(0);\n      setFocusedCol(0);\n      setCurrentDirection('across');\n      setCurrentNumber('1');\n    }, [masterClues, masterGridData, storageKey, useStorage]);\n\n    // save the guesses any time they change...\n    useEffect(() => {\n      if (gridData === null || !useStorage) {\n        return;\n      }\n\n      saveGuesses(gridData, storageKey || defaultStorageKey);\n    }, [gridData, storageKey, useStorage]);\n\n    const handleCellClick = useCallback(\n      (cellData: CellData) => {\n        if (cellData.used) {\n          const { row, col } = cellData;\n          const other = otherDirection(currentDirection);\n\n          // should this use moveTo?\n          setFocusedRow(row);\n          setFocusedCol(col);\n\n          let direction = currentDirection;\n\n          // We switch to the \"other\" direction if (a) the current direction\n          // isn't available in the clicked cell, or (b) we're already focused\n          // and the clicked cell is the focused cell, *and* the other direction\n          // is available.\n          if (\n            !cellData[currentDirection] ||\n            (focused &&\n              row === focusedRow &&\n              col === focusedCol &&\n              cellData[other])\n          ) {\n            setCurrentDirection(other);\n            direction = other;\n          }\n\n          setCurrentNumber(cellData[direction] ?? '');\n        }\n\n        focus();\n      },\n      [currentDirection, focus, focused, focusedCol, focusedRow]\n    );\n\n    const handleInputClick = useCallback<\n      React.MouseEventHandler<HTMLInputElement>\n    >(\n      (/* event */) => {\n        // *don't* event.preventDefault(), because we want the input to actually\n        // take focus\n\n        // Like general cell-clicks, cliking on the input can change direction.\n        // Unlike cell clicks, we *know* we're clicking on the already-focused\n        // cell!\n        const other = otherDirection(currentDirection);\n        const cellData = getCellData(focusedRow, focusedCol) as UsedCellData;\n\n        let direction = currentDirection;\n\n        if (focused && cellData[other]) {\n          setCurrentDirection(other);\n          direction = other;\n        }\n\n        setCurrentNumber(cellData[direction] ?? '');\n        focus();\n      },\n      [currentDirection, focus, focused, focusedCol, focusedRow, getCellData]\n    );\n\n    const handleClueSelected = useCallback(\n      (direction: Direction, number: string) => {\n        const info = clues?.[direction].find((clue) => clue.number === number);\n\n        if (!info) {\n          return;\n        }\n\n        // console.log('CrosswordProvider.handleClueSelected', { info });\n        // TODO: sanity-check info?\n        moveTo(info.row, info.col, direction);\n        focus();\n\n        if (onClueSelected) {\n          onClueSelected(direction, number);\n        }\n      },\n      [clues, focus, moveTo, onClueSelected]\n    );\n\n    const registerFocusHandler = useCallback(\n      (focusHandler: FocusHandler | null) => {\n        // console.log('CrosswordProvider.registerFocusHandler() called', {\n        //   name: focusHandler?.name ?? '(NULL)',\n        //   focusHandler,\n        // });\n\n        // *If* registeredFocusHandler is implemented as state, realize that we\n        // can't simply pass it to the setter... the useState React setter would\n        // *invoke* the function and take the return value!  So, we would have\n        // to wrap it in a functional setter (setState(() => focusHandler)).\n        // But, since we're using a Ref, this is just a simple assignment!\n        registeredFocusHandler.current = focusHandler;\n      },\n      []\n    );\n\n    // imperative commands...\n    useImperativeHandle(\n      ref,\n      () => ({\n        /**\n         * Sets focus to the crossword component.\n         */\n        focus,\n\n        /**\n         * Resets the entire crossword; clearing all answers in the grid and\n         * also any persisted data.\n         */\n        reset: () => {\n          setGridData(\n            produce((draft) => {\n              draft.forEach((rowData) => {\n                rowData.forEach((cellData) => {\n                  if (cellData.used) {\n                    cellData.guess = '';\n                  }\n                });\n              });\n            })\n          );\n\n          setClues(\n            produce((draft) => {\n              bothDirections.forEach((direction) => {\n                draft?.[direction]?.forEach((clueInfo) => {\n                  delete clueInfo.complete;\n                  delete clueInfo.correct;\n                });\n              });\n            })\n          );\n\n          if (useStorage) {\n            clearGuesses(storageKey || defaultStorageKey);\n          }\n        },\n\n        /**\n         * Fills all the answers in the grid and calls the `onLoadedCorrect`\n         * callback with _**every**_ answer.\n         */\n        fillAllAnswers: () => {\n          setGridData(\n            produce((draft) => {\n              draft.forEach((rowData) => {\n                rowData.forEach((cellData) => {\n                  if (cellData.used) {\n                    cellData.guess = cellData.answer;\n                  }\n                });\n              });\n            })\n          );\n\n          setClues(\n            produce((draft) => {\n              bothDirections.forEach((direction) => {\n                draft?.[direction].forEach((clueInfo) => {\n                  clueInfo.complete = true;\n                  clueInfo.correct = true;\n                });\n              });\n            })\n          );\n\n          // trigger onLoadedCorrect with every clue!\n          if (onLoadedCorrect) {\n            const loadedCorrect: AnswerTuple[] = [];\n            bothDirections.forEach((direction) => {\n              clues?.[direction].forEach(({ number, answer }) => {\n                loadedCorrect.push([direction, number, answer]);\n              });\n            });\n\n            onLoadedCorrect(loadedCorrect);\n          }\n        },\n\n        /**\n         * Returns whether the crossword is entirely correct or not.\n         */\n        isCrosswordCorrect: () => crosswordCorrect,\n\n        /**\n         * Sets the “guess” character for a specific grid position.\n         *\n         * @since 4.1.0\n         */\n        setGuess: (row: number, col: number, guess: string) => {\n          // REVIEW: should we force-case this?\n          setCellCharacter(row, col, guess.toUpperCase());\n        },\n      }),\n      [\n        clues,\n        crosswordCorrect,\n        focus,\n        onLoadedCorrect,\n        setCellCharacter,\n        storageKey,\n        useStorage,\n      ]\n    );\n\n    const crosswordContext = useMemo<CrosswordContextType>(\n      () => ({\n        rows,\n        cols,\n        gridData,\n        clues,\n\n        handleInputKeyDown,\n        handleInputChange,\n        handleCellClick,\n        handleInputClick,\n        handleClueSelected,\n        registerFocusHandler,\n\n        focused,\n        selectedPosition: { row: focusedRow, col: focusedCol },\n        selectedDirection: currentDirection,\n        selectedNumber: currentNumber,\n\n        crosswordCorrect,\n      }),\n      [\n        rows,\n        cols,\n        gridData,\n        clues,\n        handleInputKeyDown,\n        handleInputChange,\n        handleCellClick,\n        handleInputClick,\n        handleClueSelected,\n        registerFocusHandler,\n        focused,\n        focusedRow,\n        focusedCol,\n        currentDirection,\n        currentNumber,\n        crosswordCorrect,\n      ]\n    );\n\n    return (\n      <ThemeProvider theme={finalTheme}>\n        <CrosswordContext.Provider value={crosswordContext}>\n          {children}\n        </CrosswordContext.Provider>\n      </ThemeProvider>\n    );\n  }\n);\n\nexport default CrosswordProvider;\n\nCrosswordProvider.displayName = 'CrosswordProvider';\nCrosswordProvider.propTypes = crosswordProviderPropTypes;\nCrosswordProvider.defaultProps = {\n  theme: undefined,\n  useStorage: true,\n  storageKey: undefined,\n  onAnswerComplete: undefined,\n  onAnswerCorrect: undefined,\n  onCorrect: undefined,\n  onAnswerIncorrect: undefined,\n  onLoadedCorrect: undefined,\n  onCrosswordComplete: undefined,\n  onCrosswordCorrect: undefined,\n  onCellChange: undefined,\n  onClueSelected: undefined,\n  children: undefined,\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}