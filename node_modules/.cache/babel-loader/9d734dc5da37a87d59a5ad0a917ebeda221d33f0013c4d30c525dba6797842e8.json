{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/Users/lukecunningham/Documents/GitHub/crossword-app/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.findCorrectAnswers = exports.deserializeGuesses = exports.loadGuesses = exports.serializeGuesses = exports.saveGuesses = exports.clearGuesses = exports.byNumber = exports.createGridData = exports.fillClues = exports.createEmptyGrid = exports.calculateExtents = exports.otherDirection = exports.isAcross = exports.bothDirections = void 0;\nvar directionInfo = {\n  across: {\n    primary: 'col',\n    orthogonal: 'row'\n  },\n  down: {\n    primary: 'row',\n    orthogonal: 'col'\n  }\n};\nexports.bothDirections = Object.keys(directionInfo);\nfunction isAcross(direction) {\n  return direction === 'across';\n}\nexports.isAcross = isAcross;\nfunction otherDirection(direction) {\n  return isAcross(direction) ? 'down' : 'across';\n}\nexports.otherDirection = otherDirection;\nfunction calculateExtents(data, direction) {\n  var dir = directionInfo[direction];\n  var primaryMax = 0;\n  var orthogonalMax = 0;\n  Object.entries(data[direction]).forEach(function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n      info = _ref2[1];\n    var primary = info[dir.primary] + info.answer.length - 1;\n    if (primary > primaryMax) {\n      primaryMax = primary;\n    }\n    var orthogonal = info[dir.orthogonal];\n    if (orthogonal > orthogonalMax) {\n      orthogonalMax = orthogonal;\n    }\n  });\n  var rowColMax = {\n    row: 0,\n    col: 0\n  };\n  rowColMax[dir.primary] = primaryMax;\n  rowColMax[dir.orthogonal] = orthogonalMax;\n  return rowColMax;\n}\nexports.calculateExtents = calculateExtents;\n// const emptyCellData: Partial<CellData> = {\n//   used: false,\n//   // number: undefined, // null,\n//   // answer: '',\n//   // guess: '',\n//   // row: r,\n//   // col: c,\n//   // across: '', //null,\n//   // down: '', //null,\n// } as const;\nfunction createEmptyGrid(rows, cols) {\n  var gridData = Array(rows);\n  // Rather than [x][y] in column-major order, the cells are indexed as\n  // [row][col] in row-major order.\n  for (var r = 0; r < rows; r++) {\n    gridData[r] = Array(cols);\n    for (var c = 0; c < cols; c++) {\n      gridData[r][c] = {\n        // ...emptyCellData,\n        row: r,\n        col: c,\n        used: false\n      };\n    }\n  }\n  return gridData;\n}\nexports.createEmptyGrid = createEmptyGrid;\nfunction fillClues(gridData, clues, data, direction) {\n  var dir = directionInfo[direction];\n  Object.entries(data[direction]).forEach(function (_ref3) {\n    var _ref4 = _slicedToArray(_ref3, 2),\n      number = _ref4[0],\n      info = _ref4[1];\n    var rowStart = info.row,\n      colStart = info.col,\n      clue = info.clue,\n      answer = info.answer;\n    for (var i = 0; i < answer.length; i++) {\n      var row = rowStart + (dir.primary === 'row' ? i : 0);\n      var col = colStart + (dir.primary === 'col' ? i : 0);\n      var cellData = gridData[row][col];\n      // TODO?: check to ensure the answer is the same if it's already set?\n      cellData.used = true;\n      cellData.answer = answer[i];\n      cellData[direction] = number;\n      if (i === 0) {\n        // TODO?: check to ensure the number is the same if it's already set?\n        cellData.number = number;\n      }\n    }\n    clues[direction].push({\n      number: number,\n      clue: clue,\n      answer: answer,\n      col: colStart,\n      row: rowStart\n    });\n  });\n  clues[direction].sort(byNumber);\n}\nexports.fillClues = fillClues;\n// Given the \"nice format\" for a crossword, generate the usable data optimized\n// for rendering and our interactivity.\nfunction createGridData(data, allowNonSquare) {\n  var acrossMax = calculateExtents(data, 'across');\n  var downMax = calculateExtents(data, 'down');\n  var rows = Math.max(acrossMax.row, downMax.row) + 1;\n  var cols = Math.max(acrossMax.col, downMax.col) + 1;\n  if (!allowNonSquare) {\n    var size = Math.max(rows, cols);\n    rows = size;\n    cols = size;\n  }\n  var gridData = createEmptyGrid(rows, cols);\n  // Now fill with answers... and also collect the clues\n  var clues = {\n    across: [],\n    down: []\n  };\n  fillClues(gridData, clues, data, 'across');\n  fillClues(gridData, clues, data, 'down');\n  return {\n    rows: rows,\n    cols: cols,\n    gridData: gridData,\n    clues: clues\n  };\n}\nexports.createGridData = createGridData;\nfunction byNumber(a, b) {\n  var aNum = Number.parseInt(a.number, 10);\n  var bNum = Number.parseInt(b.number, 10);\n  return aNum - bNum;\n}\nexports.byNumber = byNumber;\nfunction clearGuesses(storageKey) {\n  if (!window.localStorage) {\n    return;\n  }\n  window.localStorage.removeItem(storageKey);\n}\nexports.clearGuesses = clearGuesses;\nfunction saveGuesses(gridData, storageKey) {\n  var _window = window,\n    localStorage = _window.localStorage;\n  if (!localStorage) {\n    return;\n  }\n  var guesses = serializeGuesses(gridData);\n  var saveData = {\n    date: Date.now(),\n    guesses: guesses\n  };\n  localStorage.setItem(storageKey, JSON.stringify(saveData));\n}\nexports.saveGuesses = saveGuesses;\nfunction serializeGuesses(gridData) {\n  var guesses = gridData.reduce(function (memo, row, r) {\n    return row.reduce(function (memoInner, cellData, c) {\n      var _a;\n      var guess = cellData.guess;\n      if (guess !== '') {\n        memoInner[\"\".concat(r, \"_\").concat(c)] = (_a = cellData.guess) !== null && _a !== void 0 ? _a : '';\n      }\n      return memoInner;\n    }, memo);\n  }, {});\n  return guesses;\n}\nexports.serializeGuesses = serializeGuesses;\nfunction loadGuesses(gridData, storageKey) {\n  var _window2 = window,\n    localStorage = _window2.localStorage;\n  if (!localStorage) {\n    return;\n  }\n  var saveRaw = localStorage.getItem(storageKey);\n  if (!saveRaw) {\n    return;\n  }\n  var saveData = JSON.parse(saveRaw);\n  // TODO: check date for expiration?\n  deserializeGuesses(gridData, saveData.guesses);\n}\nexports.loadGuesses = loadGuesses;\nfunction deserializeGuesses(gridData, guesses) {\n  Object.entries(guesses).forEach(function (_ref5) {\n    var _ref6 = _slicedToArray(_ref5, 2),\n      key = _ref6[0],\n      val = _ref6[1];\n    var _key$split = key.split('_'),\n      _key$split2 = _slicedToArray(_key$split, 2),\n      rStr = _key$split2[0],\n      cStr = _key$split2[1];\n    var r = parseInt(rStr, 10);\n    var c = parseInt(cStr, 10);\n    // ignore any out-of-bounds guesses!\n    if (r <= gridData.length - 1 && c <= gridData[0].length - 1) {\n      gridData[r][c].guess = val;\n    }\n  });\n}\nexports.deserializeGuesses = deserializeGuesses;\nfunction findCorrectAnswers(data, gridData) {\n  var correctAnswers = [];\n  exports.bothDirections.forEach(function (direction) {\n    var across = isAcross(direction);\n    Object.entries(data[direction]).forEach(function (_ref7) {\n      var _ref8 = _slicedToArray(_ref7, 2),\n        num = _ref8[0],\n        info = _ref8[1];\n      var row = info.row,\n        col = info.col;\n      var correct = true;\n      for (var i = 0; i < info.answer.length; i++) {\n        var r = across ? row : row + i;\n        var c = across ? col + i : col;\n        if (gridData[r][c].guess !== info.answer[i]) {\n          correct = false;\n          break;\n        }\n      }\n      if (correct) {\n        // same args as notifyCorrect: direction, number, answer\n        correctAnswers.push([direction, num, info.answer]);\n      }\n    });\n  });\n  return correctAnswers;\n}\nexports.findCorrectAnswers = findCorrectAnswers;","map":{"version":3,"names":["directionInfo","across","primary","orthogonal","down","exports","bothDirections","Object","keys","isAcross","direction","otherDirection","calculateExtents","data","dir","primaryMax","orthogonalMax","entries","forEach","_ref","_ref2","_slicedToArray","info","answer","length","rowColMax","row","col","createEmptyGrid","rows","cols","gridData","Array","r","c","used","fillClues","clues","_ref3","_ref4","number","rowStart","colStart","clue","i","cellData","push","sort","byNumber","createGridData","allowNonSquare","acrossMax","downMax","Math","max","size","a","b","aNum","Number","parseInt","bNum","clearGuesses","storageKey","window","localStorage","removeItem","saveGuesses","_window","guesses","serializeGuesses","saveData","date","Date","now","setItem","JSON","stringify","reduce","memo","memoInner","guess","concat","_a","loadGuesses","_window2","saveRaw","getItem","parse","deserializeGuesses","_ref5","_ref6","key","val","_key$split","split","_key$split2","rStr","cStr","findCorrectAnswers","correctAnswers","_ref7","_ref8","num","correct"],"sources":["/Users/lukecunningham/Documents/GitHub/crossword-app/node_modules/@jaredreisinger/react-crossword/src/util.ts"],"sourcesContent":["import type {\n  AnswerTuple,\n  CellData,\n  CluesData,\n  CluesInput,\n  Direction,\n  GridData,\n  UsedCellData,\n} from './types';\n\ntype RowOrCol = 'row' | 'col';\n\nconst directionInfo: Record<\n  Direction,\n  { primary: RowOrCol; orthogonal: RowOrCol }\n> = {\n  across: {\n    primary: 'col',\n    orthogonal: 'row',\n  },\n  down: {\n    primary: 'row',\n    orthogonal: 'col',\n  },\n};\n\ninterface RowColMax {\n  row: number;\n  col: number;\n}\n\nexport const bothDirections = Object.keys(directionInfo) as Direction[];\n\nexport function isAcross(direction: Direction) {\n  return direction === 'across';\n}\n\nexport function otherDirection(direction: Direction) {\n  return isAcross(direction) ? 'down' : 'across';\n}\n\nexport function calculateExtents(data: CluesInput, direction: Direction) {\n  const dir = directionInfo[direction];\n  let primaryMax = 0;\n  let orthogonalMax = 0;\n\n  Object.entries(data[direction]).forEach(([, info]) => {\n    const primary = info[dir.primary] + info.answer.length - 1;\n    if (primary > primaryMax) {\n      primaryMax = primary;\n    }\n\n    const orthogonal = info[dir.orthogonal];\n    if (orthogonal > orthogonalMax) {\n      orthogonalMax = orthogonal;\n    }\n  });\n\n  const rowColMax: RowColMax = {\n    row: 0,\n    col: 0,\n  };\n\n  rowColMax[dir.primary] = primaryMax;\n  rowColMax[dir.orthogonal] = orthogonalMax;\n\n  return rowColMax;\n}\n\n// const emptyCellData: Partial<CellData> = {\n//   used: false,\n//   // number: undefined, // null,\n//   // answer: '',\n//   // guess: '',\n//   // row: r,\n//   // col: c,\n//   // across: '', //null,\n//   // down: '', //null,\n// } as const;\n\nexport function createEmptyGrid(rows: number, cols: number) {\n  const gridData: GridData = Array(rows);\n  // Rather than [x][y] in column-major order, the cells are indexed as\n  // [row][col] in row-major order.\n  for (let r = 0; r < rows; r++) {\n    gridData[r] = Array(cols);\n    for (let c = 0; c < cols; c++) {\n      gridData[r][c] = {\n        // ...emptyCellData,\n        row: r,\n        col: c,\n        used: false,\n      };\n    }\n  }\n\n  return gridData;\n}\n\nexport function fillClues(\n  gridData: GridData,\n  clues: CluesData,\n  data: CluesInput,\n  direction: Direction\n) {\n  const dir = directionInfo[direction];\n\n  Object.entries(data[direction]).forEach(([number, info]) => {\n    const { row: rowStart, col: colStart, clue, answer } = info;\n    for (let i = 0; i < answer.length; i++) {\n      const row = rowStart + (dir.primary === 'row' ? i : 0);\n      const col = colStart + (dir.primary === 'col' ? i : 0);\n      const cellData = gridData[row][col] as UsedCellData;\n\n      // TODO?: check to ensure the answer is the same if it's already set?\n      cellData.used = true;\n      cellData.answer = answer[i];\n      cellData[direction] = number;\n\n      if (i === 0) {\n        // TODO?: check to ensure the number is the same if it's already set?\n        cellData.number = number;\n      }\n    }\n\n    clues[direction].push({\n      number,\n      clue,\n      answer,\n      col: colStart,\n      row: rowStart,\n    });\n  });\n\n  clues[direction].sort(byNumber);\n}\n\n// Given the \"nice format\" for a crossword, generate the usable data optimized\n// for rendering and our interactivity.\nexport function createGridData(data: CluesInput, allowNonSquare?: boolean) {\n  const acrossMax = calculateExtents(data, 'across');\n  const downMax = calculateExtents(data, 'down');\n\n  let rows = Math.max(acrossMax.row, downMax.row) + 1;\n  let cols = Math.max(acrossMax.col, downMax.col) + 1;\n\n  if (!allowNonSquare) {\n    const size = Math.max(rows, cols);\n    rows = size;\n    cols = size;\n  }\n\n  const gridData = createEmptyGrid(rows, cols);\n\n  // Now fill with answers... and also collect the clues\n  const clues: CluesData = {\n    across: [],\n    down: [],\n  };\n\n  fillClues(gridData, clues, data, 'across');\n  fillClues(gridData, clues, data, 'down');\n\n  return { rows, cols, gridData, clues };\n}\n\n// sort helper for clues...\ninterface HasNumber {\n  number: string;\n}\n\nexport function byNumber(a: HasNumber, b: HasNumber) {\n  const aNum = Number.parseInt(a.number, 10);\n  const bNum = Number.parseInt(b.number, 10);\n\n  return aNum - bNum;\n}\n\n// Guesses *really* only needs the \"guess\" property...\nexport type GuessData = ({ guess?: string } | CellData)[][];\n\nexport function clearGuesses(storageKey: string) {\n  if (!window.localStorage) {\n    return;\n  }\n\n  window.localStorage.removeItem(storageKey);\n}\n\nexport function saveGuesses(gridData: GuessData, storageKey: string) {\n  const { localStorage } = window;\n  if (!localStorage) {\n    return;\n  }\n\n  const guesses = serializeGuesses(gridData);\n\n  const saveData = {\n    date: Date.now(),\n    guesses,\n  };\n\n  localStorage.setItem(storageKey, JSON.stringify(saveData));\n}\n\nexport function serializeGuesses(gridData: GuessData) {\n  const guesses = gridData.reduce<Record<string, string>>(\n    (memo, row, r) =>\n      row.reduce<Record<string, string>>((memoInner, cellData, c) => {\n        const { guess } = cellData as UsedCellData;\n        if (guess !== '') {\n          memoInner[`${r}_${c}`] = (cellData as UsedCellData).guess ?? '';\n        }\n        return memoInner;\n      }, memo),\n    {}\n  );\n\n  return guesses;\n}\n\nexport function loadGuesses(gridData: GuessData, storageKey: string) {\n  const { localStorage } = window;\n  if (!localStorage) {\n    return;\n  }\n\n  const saveRaw = localStorage.getItem(storageKey);\n  if (!saveRaw) {\n    return;\n  }\n\n  const saveData = JSON.parse(saveRaw);\n\n  // TODO: check date for expiration?\n  deserializeGuesses(gridData, saveData.guesses);\n}\n\nexport function deserializeGuesses(\n  gridData: GuessData,\n  guesses: Record<string, string>\n) {\n  Object.entries(guesses).forEach(([key, val]) => {\n    const [rStr, cStr] = key.split('_');\n    const r = parseInt(rStr, 10);\n    const c = parseInt(cStr, 10);\n    // ignore any out-of-bounds guesses!\n    if (r <= gridData.length - 1 && c <= gridData[0].length - 1) {\n      (gridData[r][c] as UsedCellData).guess = val;\n    }\n  });\n}\n\nexport function findCorrectAnswers(data: CluesInput, gridData: GuessData) {\n  const correctAnswers: AnswerTuple[] = [];\n\n  bothDirections.forEach((direction) => {\n    const across = isAcross(direction);\n    Object.entries(data[direction]).forEach(([num, info]) => {\n      const { row, col } = info;\n      let correct = true;\n      for (let i = 0; i < info.answer.length; i++) {\n        const r = across ? row : row + i;\n        const c = across ? col + i : col;\n        if ((gridData[r][c] as UsedCellData).guess !== info.answer[i]) {\n          correct = false;\n          break;\n        }\n      }\n      if (correct) {\n        // same args as notifyCorrect: direction, number, answer\n        correctAnswers.push([direction, num, info.answer]);\n      }\n    });\n  });\n\n  return correctAnswers;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}